const axios = require('axios');
const CONFIG = require('../config/config');

/**
 * Generates animation commands for a 3D model using the Gemini LLM API.
 * This function takes the model's object hierarchy and properties, builds a detailed prompt,
 * sends it to Gemini, and parses the resulting animation command sequence.
 * @param {object} hierarchyData - The object hierarchy data from Forge (contains structure of the model).
 * @param {object} propertiesData - The properties data from Forge (contains properties for each object).
 * @returns {Promise<Array>} - Returns a JSON array of animation commands as generated by Gemini.
 */
async function generateAnimationWithGemini(hierarchyData, propertiesData) {
  /**
   * Recursively describes the model hierarchy as a text outline.
   * Each node is indented according to its depth in the hierarchy.
   * @param {object} node - The current node in the hierarchy.
   * @param {number} level - The current depth (used for indentation).
   * @returns {string} - Textual description of the hierarchy subtree.
   */
  function describeHierarchy(node, level = 0) {
    let description = '  '.repeat(level) + `- ${node.name} (ID: ${node.objectid})\n`;
    if (node.objects) {
      node.objects.forEach(child => {
        description += describeHierarchy(child, level + 1);
      });
    }
    return description;
  }

  // Build a text description of the model hierarchy for the prompt
  let hierarchyDescription = "Model Hierarchy:\n";
  hierarchyData.data.objects.forEach(root => {
    hierarchyDescription += describeHierarchy(root);
  });

  // Build a text description of key properties for each object for the prompt
  let propertiesDescription = "Key Properties:\n";
  propertiesData.data.collection.forEach(item => {
    propertiesDescription += `- ${item.name} (ID: ${item.objectid}):\n`;
    for (const [category, props] of Object.entries(item.properties)) {
      if (typeof props === 'object') {
        propertiesDescription += `  • ${category}:\n`;
        for (const [key, value] of Object.entries(props)) {
          propertiesDescription += `    ◦ ${key}: ${value}\n`;
        }
      } else {
        propertiesDescription += `  • ${category}: ${props}\n`;
      }
    }
  });

  // Compose the prompt for Gemini LLM, including guidelines and expected output format
  const prompt = `
You are an expert 3D animation assistant for Autodesk Forge models. 
Generate a sequence of animation commands for the following fragments that will create a logical, visually appealing animation of disassembly.

${hierarchyDescription}

${propertiesDescription}

Command format (JSON array of objects):
[
  {
    "fragmentId": <number>,
    "action": "rotate" | "scale" | "translate",
    "params": {
      // For "rotate": "axis" ("x","y","z"), "angle": <degrees>
      // For "scale": "factor": <number>
      // For "translate": "x": <number>, "y": <number>, "z": <number>
    }
  }
]

Guidelines:
1. Create an disassembly view showing assembly relationships
2. Move parts along logical axes based on their position in the assembly
3. Rotate rotating components (shaft, rotor, screws) to show movements of disassembly
4. Scale small parts to make them more visible
5. Use reasonable translations depending on part size for disassembly
6. Include 8-12 commands for a comprehensive animation at the end assembly should disassemble completely and then reassemble
7. Prioritize moving outer components first then inner ones
8. Consider mechanical relationships between parts
9. Also add rotation for parts that have rotational movement

Generate only the JSON array with no additional text.
`.trim();

  try {
    // Call Gemini API with the constructed prompt
    const response = await axios.post(
      'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + CONFIG.GEMINI_API_KEY,
      {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
          temperature: 0.7, // Controls randomness of output
          maxOutputTokens: 1000 // Limits the length of the response
        }
      },
      {
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000
      }
    );

    // Extract the text response from Gemini
    let text = response.data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";

    // Remove code block markers (```json or ```) if present in the response
    if (text.startsWith("```json")) text = text.replace(/^```json/, "").replace(/```$/, "").trim();
    else if (text.startsWith("```")) text = text.replace(/^```/, "").replace(/```$/, "").trim();

    // Parse the JSON array from Gemini's response
    try {
      return JSON.parse(text);
    } catch (parseError) {
      // Log and throw error if JSON parsing fails
      console.error("JSON parse failed:", parseError.message);
      throw new Error(`Invalid JSON from Gemini: ${text.substring(0, 100)}...`);
    }
  } catch (error) {
    // Log and throw error if Gemini API call fails
    console.error("Gemini API error:", error.message);
    throw new Error(`Animation generation failed: ${error.response?.data?.error?.message || error.message}`);
  }
}

module.exports = { generateAnimationWithGemini };